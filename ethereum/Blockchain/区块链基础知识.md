# 区块链基础知识

[TOC]

# 区块

wiki上对于区块链的解释：
是借由密码学串接并保护内容的串连文字记录（又称区块）。

每一个区块包含了前一个区块的加密散列、相应时间戳记以及交易数据（通常用默克尔树(Merkle tree)算法计算的散列值表示），这样的设计使得区块内容具有难以篡改的特性。用区块链技术所串接的分布式账本能让两方有效纪录交易，且可永久查验此交易。

### 区块的结构

区块源码：
https://github.com/ethereum/go-ethereum/blob/389da6aa480bdf9a78d865caabc39ebeebb1d416/core/types/block.go#L321
**区块**
![img](http://0rac1esys.cn:3000/uploads/upload_6d43b83a644d21f5b8d9ba7dd7e1a4a9.png)

有源代码可知，区块是一种数据结构，其包含区块头header、所有叔块（以太坊规定为最多两个）的区块头uncles、当前区块的所有交易transactions。以及其他信息如td是用于计算总难度的参数

**区块头**
![img](http://0rac1esys.cn:3000/uploads/upload_0ba35f9cf219d5e4f3a4c36120559fe0.png)

区块头包含了

- ParentHash： 该区块的父区块的区块头哈希
- UncleHash： 该区块所包含的叔块的区块头list的哈希值
- Coinbase： 打包该区块矿工的地址，矿工费和打包区块的奖金将发送到这个地址
- Root： 存储账户状态的Merkle树的根节点的哈希
- TxHash： 存储该区块中的交易的Merkle树的根节点的哈希
- ReceiptHash：存储该区块的交易的回单的Merkle树的根节点的哈希*https://learnblockchain.cn/article/324*
- Bloom： 交易日志的布隆过滤器，用于查询
- Difficulty： 该区块的难度
- Number： 区块号，也是区块高度，也是所有祖先区块的数量
- GasLimit： 该区块的汽油（gas）上限
- GasUsed： 该区块使用的汽油（gas）
- Time： 区块开始打包时间戳（调用Engine.Prepare函数的时候设置）
- MixDigest： 该哈希值与Nonce值一起证明该区块上已经进行了足够的计算，用于证明挖矿成功
- Nonce： 该哈希值与MixDigest哈希值一起证明该区块上已经进行了足够的计算，用于证明挖矿成功
- Extra： 矿工可控制的自定义信息

**区块体**
![img](http://0rac1esys.cn:3000/uploads/upload_24efcc6fa249558ef9993ec0d494edc3.png)

使用web3查看一个区块信息
![img](http://0rac1esys.cn:3000/uploads/upload_ede2c54e17ae7f3b7c80249d8cb133ef.png)
使用etherscan查看此区块的信息
![img](http://0rac1esys.cn:3000/uploads/upload_e2cf8dc5b59de3ea0ac179c9751d8cbc.png)

### 区块是如何出块的

**出块过程**
交易在生成之后会被以太坊节点广播至网络，交易会被放到交易池（txPool）中，由矿工对交易进行验证然后放到正在打包的区块中，当选择好了区块中所要包含的交易之后，矿工就开始了挖矿过程（PoW），当矿工在挖矿竞争中取得胜利之后，该矿工的区块数据就可以被写入到区块链中。

**出块原则**
决定区块链出块的是区块链的共识机制，如以太坊目前决定出块的机制有两种，一种是POW工作量证明，一 种是GHOST协议

**POW工作量证明**
总体来说就是矿工要想成功挖出一个区块，必须不停的穷举随机数nonce，直到通过哈希算法得到的区块hash值小于或等于目标值target。代码层可参照*https://www.jianshu.com/p/e46d5bf59e3b*

**GHOST协议**
以太坊中将出块时间大约为12秒，因此也会导致一个问题，就是在这12秒内，并不是所有的节点都收到了某一个区块是新区块的信息，而且12秒内很有可能有很多节点都同时挖出了区块，那么就会出现一部分人以为这个区块最新，一部分人以为那个区块最新，这样就出现了分叉。GHOST协议的目的就是怎么样才能激励其他分叉的叔块快速地与大矿池的主链合并，

在这里举个例子进行说明：

![img](http://0rac1esys.cn:3000/uploads/upload_0805b709239bfe772689fb7c67dcf139.png)

比如在上面的图中，2-1、2-2、3-1、3-2、3-3、3-4都为叔块，中间的1、2、3、4为主链，当3出块时，且其为大矿池，那么如果它想让其他的小矿池与其主链快速合并，那么它就要进行招安，比如首先它会先选择3-1、3-2两个叔块（最多两个），并将这两个叔块的hash写到即将要挖出来的第四个区块中，即意味着如果成功挖出第四个区块，这两个叔块的挖矿者将会分别得到出块奖励（即3eth）*7/8的奖励，而大矿池也将得到出块奖励（即3eth）*1/32 * 2（招安的叔块数）+ 出块奖励 的奖励。修改完区块上的叔块hash等信息后，大矿池将开始拼命挖矿，因为其算力高，很快就挖到了第四个区块并且发送到了网络中，然后这时候那些还正在挖掘3号块或者四号块的节点，特别是3-1、3-2的矿工收到这个区块后，都会马上来验证这个4号区块的合法性，验证通过后就会停下手中的挖矿工作。在这个过程中，3-1、3-2的矿工收到区块后会发现自己是被招安的叔块，因为它能够得到相应的区块奖励，而且它继续挖矿而不合并能够战胜大矿池的可能性并不大，那么接受招安就是一个十分理智的决定。

但是这个时候3-3、3-4就得不到奖励了吗，当然不是，当要挖第5号区块的时候，我们就可以将这两个叔块进行招安，但是这里与上面唯一不同的地方就是这里的比例是6/8，因为他们与第5号区块的代数相差2，由之前所说的概念我们也知道，奖励比例是与间隔代数成反比的。这样出现的叔块就会一个个地被招安，直至它超出了7代。
此链接讲解更准确*https://blog.csdn.net/t46414704152abc/article/details/81191804*

交易池中有许多交易存在，矿工是如何从交易池中选择交易的呢？其实交易池会对各个交易进行排序，提供的矿工费（gas）高的交易会排在前面。因此，矿工会优先选择奖励高的交易打包至区块。这也就是为什么gas值高的交易会被处理的较快的原因。

# 交易

（私钥+RLP序列化交易数据的哈希）通过“椭圆曲线加密算法”得到交易的签名（R，S）。交易前面加上交易数据即是一笔完整的交易。

### UTXO模型是什么

UTXO指未花费的交易输出。以比特币为例，要理解UTXO，首先我们必须知道，在比特币中是不存在账户的，有的只是一笔笔交易。如图所示，假定矿工A挖出5BTC，经过交易Transaction1花费出1BTC给B，花费4BTC给C。在此笔交易中，我们称4BTC和1BTC都是交易Transaction1的“交易输出”，其中的1BTC继续经过交易Transaction3转移给其他人，而4BTC未有与之关联的其他交易，我们称其为“未花费的交易输出”。
![img](http://0rac1esys.cn:3000/uploads/upload_5f4ebd583c9aa58541ed5e9cb553cca2.png)

UTXO本质上来讲就是用比特币拥有者的公钥哈希锁定一个数字（比特币数量），具体就是一个数字加一个锁定脚本。所有的UTXO都被存在数据库中，花费比特币其实是花费掉属于你的UTXO，并生成新的UTXO，用接受者的公钥哈希进行锁定。锁定脚本： OP_DUP OP_HASH160<pubKeyHash>OP_EQUALVERIFY OP_CHECKSIG，锁定脚本中只有公钥哈希是可变的，其它操作符都是固定的。锁定脚本里是谁的公钥哈希，谁就是这个UTXO的拥有者，谁就能花费这笔UTXO。

因为我们知道，在比特币中是没有账户余额的概念的，那么我们如何知道一个账户的比特币余额呢？答案就是UTXO，当一笔交易存在UTXO时，此UTXO就关联了一个公钥，（可以通过解锁脚本验证谁有权使用此笔UTXO）我们将所有交易中某个人所拥有的可支配的UTXO相加，所得的数额就是此账户的余额。而账户的余额，也可以说是很多的UTXO。

在比特币的交易中，因为没有账户余额的概念，所有我们每次交易中发出去的，只能是一个或者多个UTXO，如果UTXO的数额并不能刚好等于需要花费的金额，那么多余的将发送到一个找零地址。

### 交易模型

比特币：UTXO交易模型
通过交易创建新的UTXO
![img](http://0rac1esys.cn:3000/uploads/upload_5f4ebd583c9aa58541ed5e9cb553cca2.png)
以太坊：账户交易模型
通过交易改变世界状态（账户状态）
![img](http://0rac1esys.cn:3000/uploads/upload_3ee40f3c9071e3cd311d773f91993722.png)

### 以太坊和比特币的交易和区别

比特币是基于UTXO模型进行的交易,以太坊是基于账户模型交易的。

**比特币交易的特点**：

优点：
计算是在链外的，交易本身既是结果也是证明。节点只做验证即可，不需要对交易进行额外的计算，也没有额外的状态存储。交易本身的输出 UTXO 的计算是在钱包完成的，这样交易的计算负担完全由钱包来承担，一定程度上减少了链的负担。
除 Coinbase 交易外，交易的 Input 始终是链接在某个 UTXO 后面。交易无法被重放，并且交易的先后顺序和依赖关系容易被验证，交易是否被消费也容易被举证。
UTXO 模型是无状态的，更容易并发处理。

缺点：
无法实现一些比较复杂的逻辑，可编程性差。对于复杂逻辑，或者需要状态保存的合约，实现难度大，且状态空间利用率比较低。
当 Input 较多时，见证脚本也会增多。而签名本身是比较消耗 CPU 和存储空间的。

**以太坊交易的特点：**

优点：
合约以代码形式保存在 Account 中，并且 Account 拥有自身状态。这种模型具有更好的可编程性，容易开发人员理解，场景更广泛。
批量交易的成本较低。设想矿池向矿工支付手续费，UTXO 中因为每个 Input 和 Out 都需要单独 Witness script 或者 Locking script，交易本身会非常大，签名验证和交易存储都需要消耗链上宝贵的资源。而 Account 模型可以通过合约的方式极大的降低成本。

缺点：
Account 模型交易之间没有依赖性，需要解决重放问题。

# 签名

### 公钥、私钥是什么？

私钥：以太坊的私钥是一个32字节的数，私钥可以由伪随机算法(PRNG)产生。其实0也是一个合法的私钥，只不过这是一个特殊私钥，以太坊的创世区块就是这个私钥生成的。
公钥：以太坊的非压缩公钥是一个65字节的数，这个是继承至比特币的。但以太坊只使用了其中64个字节，这64个字节中，32字节表示椭圆曲线的X坐标，32字节表示椭圆曲线的Y坐标。这个XY坐标是私钥通过ECDSA-secp256k1推导出来的。所以说，椭圆曲线算法的公钥是通过私钥计算出来的。而反过来，用公钥推导私钥，以现有计算机的计算几乎是不可能的。

### 地址是如何生成的
![](/uploads/upload_96b987f82d8c4ed30887c36df6720589.png)

1.生成 256 位随机数作为私钥。
18e14a7b6a307f426a94f8114701e7c8e774e7f9a47e2c2035db29a206321725
2.将私钥转化为 secp256k1 非压缩格式的公钥，即 512 位的公钥。
04
　　50863ad64a87ae8a2fe83c1af1a8403cb53f53e486d8511dad8a04887e5b2352
　　2cd470243453a299fa9e77237716103abc11a1df38855ed6f2ee187e9c582ba6
3.使用散列算法 Keccak256 计算公钥的哈希值，转化为十六进制字符串。
fc12ad814631ba689f7abe671016f75c54c607f082ae6b0881fac0abeda21781
4.取十六进制字符串的后 40 个字母，开头加上 0x 作为地址（不算0x，共20个字节）。
0x1016f75c54c607f082ae6b0881fac0abeda21781

### 如何验证身份？是否是私钥签名?

1.交易验证节点接收到Alice发起转账原始交易和她的签名（r,s,v）。
2.校验Alice签名，包括检查recoveryID，然后结合签名和交易Hash恢复出Alice的公钥Q。
3.对公钥Q进行Hash，截取后20字节，得到Alice的账户地址。
4.对比原始交易中的from地址与演算恢复的Alice地址是否相同，如果相同则证明本次Alice的转账交易是合法的，否则拒绝该交易。

（签名验证实质上是使用公钥Q对交易进行解密的过程。）

2）校验签名（r校验）：
节点收到对方发来的消息和签名后，会先做一个“recover”的动作，用消息和签名推导出对方的公钥。再通过公钥，签名，消息的哈希值计算出一个叫“r”的值，这个r是签名的一部分，校验签名就是拿计算出来的r和签名中携带的r经行对比，如果一致就校验通过。

### 私钥是怎么对交易进行签名的？
1.Alice的DApp工具生成一个随机数，作为她账户的私钥k。（生成私钥）
2.在椭圆曲线secp256k1上生成P点，根据等式Q=kP，该曲线上所得点Q的坐标（x，y）经过数学处理就可以得到Alice的公钥，公钥经过Hash之后再截断便得到了Alice在以太坊网络中唯一的账户地址。（私钥推导出公钥）
3.当Alice第一次向Bob转账1个ETH时，生成如下交易信息：
rawTx = {
nonce: 0,
gasPrice: 50000000000,
gasLimit: 120000,
to: '0xC82AA3a402a737284070eA482FfC2471102997cb',
value: 1000000000000000000,
data: '0x00ffee'
};
4.Alice 的 DApp 对转账交易 tx 进行 RLP 编码，再进行 SHA-3 的 Hash，最后对 Hash 进行签名，得到签名结果为 65 字节的（r, s, v）。其中 r 和 s 分别为 32 字节，是签名的主体部分；v=27+(r % 2)，可看作签名结果的一种简单校验，在以太坊中作为恢复签名的 recoveryID。
  
（签名实质上是使用私钥k对交易摘要进行加密的过程。）

### 冷、热、软、硬钱包区别，在安全上有什么区别

1）冷钱包：冷钱包其实可以翻译成“离线钱包”，采取分散存储方式，每个地址存确定数量的比特币；安全性高。
2）热钱包：热钱包是指互联网能够访问你私钥的钱包；安全性比冷钱包差。
3）硬件钱包：是用于存储加密资产的专用电子设备，其功能就是将私钥存储在内部的芯片内，私钥永远都不会离开设备，因此很安全。私钥通过助记词生成。（Ledger和Trezor是使用最广泛的硬件钱包）
4）软件钱包：通过软件存储私钥。安全性比硬件钱包差。

### Keystore是什么

keystore 是使用输入的密码加密过后的私钥, 使用 keystore 进行交易转账等钱包操作, 必须知道该 keystore 的密码。

### 助记词是什么

助记词则是通过某个算法把这64个字符转换成一系列的单词（可以是英文、法文、中文甚至是你会的方言）, 它最早是由 BIP39提案产生的 , 可以是12个, 15个, 18个, 21个, 24个特定的单词。这些单词有一个统一的、固定的词库, 并不是凭空而来。

# 共识

### 比特币和以太坊各用的什么共识，共识流程

比特币：共识的作用（解决的问题）：保证每一笔交易在所有记账节点上的一致性（共识机制的实际根本问题是某个节点如何添加一个区块到区块链中而得到全网的同意）。
达成共识的流程（以及如何决定出块和出块者）：
1.每产生一个新的交易向全网广播。
2.全节点将收到的交易信息纳入一个候选区块中，并将其他很多交易打包在一起。
3.全节点尝试在自己的候选区块上进行具有足够难度的工作量证明。
4.当某个全节点完成了工作量证明，向全网广播此区块的完成结果。
其他节点验证其完成结果。
5.其他节点若验证通过，将此区块添加到区块链中。

以太坊共识机制（工作量证明使用Ethash， Dagger-Hashimoto算法的改良版本）
以太坊有四个版本，前沿（Frontier）、家园（Homestead）、大都会（Metropolis）和宁静（Serenity），从以太坊的规划来看，前三个版本使用共识机制PoW，到宁静时，再转为PoS（Proof of Stake，权益证明），目前使用PoW。

### 共识层面有什么安全风险，如何攻击

针对共识的攻击：
1.女巫攻击
由于PoW共识机制是根据算力来竞争记账权的，恶意节点产生再多的账户也没有用。
2.恶意节点不断打包非法的交易广播到全网
只有找到正确的nonce值才能广播到全网中，打包非法交易对自己没有任何好处，而且会消耗经济成本，包括硬件设施、电力、维护。
3.%51攻击
只要掌握全网的%51算力之后，用这些算力挖另外一条最长合法链来回滚其他矿工挖出的合法链上的交易。但是因为成本和风险都巨大，所以成功率很低。

### EOS共识

第一版白皮书采用的是DPoS（委托权益证明）
其通过赋予EOS通证持有人投票权，选出21个“超级节点”来担任记账人的角色，保证整个网络的正常运行。21个超级节点轮流负责记账，每一个区块产生后，会按照顺序传递到下一个超级节点中，第二个超级节点要负责打包新的区块，同时确认上一区块的内容，当某一区块被超过2/3的超级节点确认后，该区块将被确认为不可逆区块。
最新版为BFT-DPoS，DPoS共识加上BFT算法后，验证时不再按照出块顺序由超级节点一个个验证区块内容，而是让出块节点成为主节点，出块后同时向剩下20个节点进行广播，并获得节点的验证反馈，如果有超过2/3的节点验证通过，则该区块成为不可逆区块。BFT可以使得EOS的区块确认速度显著增加。目前采用BFT-DPoS共识机制的EOS可以实现0.5s的出块速度，1s实现区块的不可逆转。为避免因出块速度过快而漏块，EOS的超级节点会按照其地理位置分布轮流成为主节点，尽可能减少超级节点间的网络延迟，同时规定每个超级节点连续生产6个块，至少保证6个区块中的前几个能确认完成，不会出现整个超级节点被跳过的现象。


### POW、POS、DPOS、拜占庭共识及其区别

**1.工作量证明(Proof of Work，简称POW):**

可简单理解为一份证明，证明你做过一定量的工作。通过查看工作结果，就能知道你完成了指定量的工作。区块链共识算法用的最多的就是POW。比特币和以太坊都是基于POW的共识机制。

例：比特币在区块的生成过程中使用的就是POW机制，简单理解就是大家共同争夺记账权利，谁先抢到并正确完成记账工作，谁就得到系统的奖励，奖励为比特币，也就是所谓的“挖矿”。矿工（参与挖矿的人）通过计算机的算力去完成这个记账工作，这个拥有计算能力的专业计算机就是所谓的“矿机”。

**优点：**

①完全去中心化，节点自由进出，避免了建立和维护中心化信用机构的成本。

②只要网络破坏者的算力不超过全网总算力的50%，网络的交易状态就能达成一致，并不可篡改历史记录。

③投入越多算力，获得记账权概率越大，越有可能产生新的区块奖励。

**缺点：**

①目前比特币挖矿造成大量的算力和能源浪费。

②挖矿的激励机制也造成挖矿算力的高度集中

③结算周期长，每秒最多结算7笔交易，不适合商业应用。

**2.权益证明(Proof of Stake，简称POS):**

通过持有Token（代币）的数量和时长来决定你获得记账的机率，类似于股票的分红制度，持有股权越多的人就能够获得更多的分红。Token相当于区块链系统的权益。目前有很多数字资产用pow发行新币。

**优点：**

①降低了POW机制的资源浪费。

②加快了运算速度，也可以理解为工作量证明的升级版

**缺点**：

拥有币龄越长的节点获得记账权的几率越大，容易导致马太效应，富者越富，权益会越来越集中,从而失去公正性。

**3.委托权益证明(Delegated Proof of Stake，简称DPOS):**

是基于POS衍生出的更专业的解决方案，类似于董事会投票，指拥有Token的人投票给固定的节点，选举若干代理人，由代理人负责验证和记账。不同于POW和POS的全网都可以参与记账竞争，DPOS的记账节点在一定时间段内是确定的。

为了激励更多人参与竞选，系统会生成少量代币作为奖励。比特股就采用该方式。

**优点：**

相较pow，dpos大幅提高区块链处理数据的能力，甚至可以实现秒到账，同时也大幅降低维护区块链网络安全的费用。

**缺点：**

去中心程度较弱，节点代理是人为选出的，公平性相比POS较低，依赖于代币的增发来维持代理节点的稳定性。

**4.验证池共识机制Pool**

这是一种基于传统的分布式一致性技术，加上数据验证的机制，是目前行业链大范围在使用的共识机制；

**优点**：不需要依赖代币也可以实现秒级共识验证；

**缺点**：去中心化程度弱，更适合多方参与的多中心商业模式；

**5.拜占庭共识PBFT**

**优点**：

- 效率高
  PBFT要求所有节点之间的两两通信，因此这种通信机制要求节点数量不能太多，通常是几十个，在这种模式下，节点达成一致的速度更快，延时更低。
- 吞吐量高
  节点数量的控制，使PBFT网络不用像大型PoW网络那样，受限于处理能力最低的节点；因此带来全网吞吐量的大幅提升。
- 节能
  无须使用工作量证明的耗电模式，因此更加节能环保。

**缺点**：

- 可扩展性及去中心化程度较弱
  由于节点数量的限制，因此可扩展性较弱；同时节点需要选举、或者许可，不像PoW节点那样可以自由加入，去中心化程度较弱。
- 容错性较低
  PoW网络的容错性是50%，也就是须防范51%攻击；而PBFT容错性只有三分之一，也就是34%的恶意节点即可发起攻击。

总结：每一种共识机制都不能同时满足安全、效率、公平。去中心程度越弱，安全性就越低，区块链的速度就越快；去中心化程度越强，安全性就会越高，区块链的速度就会越慢。POW完全去中心化，但运行效率太低。POS提高了效率，但却降低了公平与安全。DPOS有强烈的中心化特性，却在短期内效率最高。目前行业区块链大范围使用Pool共识。

![共识算法对比](http://0rac1esys.cn:3000/uploads/upload_7daf8ec5ed6dc6134f768d5cbae76a74.png)
![img](http://0rac1esys.cn:3000/uploads/upload_e752b829d3b2257c1c090434f67090d1.png)

### dpos为何衍化，有什么优势

DPOS共识机制是基于POW及POS的基础上，出现的一种基于投票选举的共识算法。在DPOS共识制度下，持币人根据手中持有的代币投票选出一定数量的代表，来负责生产区块和运营网络。如果生产者不称职，就有随时有可能被投票出局；而持币者也可以随时通过投票更换这些代表，以维系链上系统的“长久纯洁性”。

DPOS的优势就在于能将维系网络运行的能源消耗降到最低，以一种低成本的方式来管理整个链上的运行，这就很大程度上解决了POW的能源耗损问题。同时，更加“去中心化”的管理方式，将区块链网络运行的决定权分散到全网的各个节点手中，这就很大程度上避免了POS容易出现的被庄家操纵的“控股”现象。DPOS共识机制的出现，将通过实施区块链上的“民主”来对抗“中心化”所产生的负面效应，用被公选的“弱中心化”的方式来提高全网运维的效率。

### VRF共识

VRF(Verifiable Random Function）: 可验证随机函数。

随机：一个理想的哈希函数，其值域应该是离散的、均匀分布的，给定不同的输入值，其输出值应该没有规律，随机的分布在值域区间内。

再看一个简单的哈希函数变种，即结合了密钥secret的哈希函数，比如result = SHA256(secret，info)，那么要得到结果result，仅仅拥有info是不够的，必须要知道secret才能计算出来，或者说我们已经拥有了结果result和info，但是必须知道secret才能验证info和result是否是匹配，这就是带密钥的哈希函数。此时引出另一个问题，有没有可能不通过密匙secret，也能验证info和result是匹配的？于是就有了可验证的随机函数即：VRF。实现原理：结合了非对称加密技术的哈希函数，例如：result = VRF_Hash(SK, info), SK是私钥，不公开，和SK对应的公钥PK，需要发送给验证者。

具体操作流程如下:

1、证明者生成一对密钥，SK、PK;

2、证明者计算result = VRF_Hash(SK，info);

3、证明者计算proof = VRF_Proof(SK，info);

4、证明者把result和proof递交给验证者;

5、 验证者计算result = VRF_P2H(proof)是否成立，若成立，继续下面的步骤，否则中止;

6、 证明者把PK，info递交给验证者;

7、 验证者计算True/False = VRF_Verify(PK, info, proof) ，True表示验证通过，False表示验证未通过。

所谓的验证通过，就是指proof是否是通过info生成的，通过proof是否可以计算出result，从而推导出info和result是否对应匹配、证明者给出的材料是否有问题。在整个操作流程中，证明者始终没有出示自己的私钥SK，验证者却可以推导出info和result是否对应匹配，这就是VRF的妙用。

### 拜占庭硬分叉

2015年，以太坊创始人Vitalik Buterin及其团队推出以太坊“四步走”发展路线：Frontier（前沿）、Homestead（家园）、Metropolis（大都会）和Serenity（宁静）。以太坊网络升级到大都会阶段，将为以太坊带来大量重要特性，并且由于开发者精力有限，因此升级大都会需要经过两次硬分叉，即拜占庭硬分叉与君士坦丁堡硬分叉。基于创始人Vitalik是俄罗斯人，俄罗斯在历史上继承了拜占庭帝国的衣钵，因此以太坊团队以拜占庭与君士坦丁堡为两次硬分叉命名。

以太坊的硬分叉是对以太坊底层协议的改变，创建新的规则，提高整个系统。协议改变在某个特定区块上被激活。所有的以太坊客户端都需要升级，否则将停留在遵循旧规则的老链上。

对于硬分叉，多数人存在认知误区，认为所有的硬分叉都必然导致链条分裂，实际上并不是如此。2016年以太坊硬分叉由于提出的修改方案在社区存在很大争议，不是所有人同意而失败，最终导致链条分裂为ETH与ETC。但是大都会升级基本得到社区一致同意，拜占庭硬分叉不是紧急情况下的临时处理办法，因此拜占庭硬分叉只是软件的更新，基本不会导致以太坊发生分裂，不会产生新的以太币。升级后，早期软件版本将不再与新网络兼容。

拜占庭硬分叉是以太坊升级大都会的第一阶段，本次硬分叉将为智能合约的开发者提供灵活的参数，对于开发者更为友好；同时，为后期大都会升级引入ZK-Snarks（零知识证明）等技术参数或方法做了准备；延迟引爆难度炸弹，将冰河期推迟1年到来；矿工挖矿的区块奖励降低40%，从5个以太币降低到3个以太币。

具体而言：硬分叉带来的改变包括以下方面:

1、增加‘REVERT’操作符，允许处理错误不需要花费掉所有的gas(EIP 140)

2、现在交易接收方可以包括一个状态字段，用以指出交易成功还是失败(EIP 658)

3、在alt_bn128 (EIP 196)和配对检查上 (EIP 197)增加椭圆曲线和标量乘法，允许ZK-Snarks和其它加密数学

4、支持大数模幂 (EIP 198)，实现RSA签名验证和其它加密应用。

5、支持可变长度返回值 (EIP 211)

6、增加‘STATICCALL’操作符，允许对其它合约进行非状态改变调用(EIP 214)

7、修改难度调整公式，将叔块计算在内(EIP 100)

8、冰河期/难度炸弹延期一年，区块奖励从5个以太币降到3个以太币 (EIP 649)

# 以太坊

### 以太坊基本知识

#### 以太坊是什么

以太坊是一个开源的有智能合约功能的公共区块链平台，允许任何人在平台上建立通过区块链技术运行的去中心化应用。通过其专用加密货币以太币（Ether，简称“ETH”）提供去中心化的以太虚拟机（Ethereum Virtual Machine）来处理点对点合约。

具体来说，以太坊通过一套图灵完备的脚本语言（Ethereum Virtual Machinecode，简称EVM语言）来建立应用，它类似于汇编语言。我们知道，直接用汇编语言编程是非常痛苦的，但以太坊里的编程并不需要直接使用EVM语言，而是类似C语言、Python、Lisp等高级语言，再通过编译器转成EVM语言。智能合约是在以太坊虚拟机上运行的应用程序。

#### 智能合约开发语言

以太坊具有四种专用语言：Serpent (受 python 启发）、Solidity(受Javascript启发）、Mutan(受Go启发）和LLL（受Lisp 启发），都是为面向合约编程而从启程开始设计的语言。

#### 和比特币的区别

1. 出块时间：以太坊出块时间15s左右（最新好像是20s左右），比特币10分钟左右
2. 以太坊是基于账户的账本，比特币是基于交易的账本
3. 以太坊引入了编程上图灵完备的智能合约功能
   其他的区别还有以太币是无限量发行的，而比特币会每四年减半，总量2100万。还有以太坊有叔块的概念

#### 以太坊区块链浏览器

```
https://etherscan.io/
```

区块链浏览器：建立在普通的中心化网络上，专门为用户提供浏览和查询区块链上信息。

因为区块链公开透明的特质，它需要有一个媒介能够让矿工、监管者、开发者、交易者等等用户看到链上的情况，比如某笔交易、某块区块、当前链高。

区块链浏览器就是这个媒介，在这里，我们可以看到链上的所有信息（除了必须，比如真实身份），只需要输入某钱包地址或者某笔交易的ID，即可查询它们的详细信息。

#### 看一笔交易

![img](http://0rac1esys.cn:3000/uploads/upload_3921049ba259a042a4fd1ff48d515412.png)

Nonce交易的计数

#### gas、gas price、gas limit

gas设置参考：https://etherscan.io/gasTracker

##### gas：

Gas对应于一个交易(Transaction)中以太坊虚拟机(EVM)的实际运算步数，你提交的交易需要EVM进行的计算量越大，所需的Gas消耗量就越高了。通俗理解，Gas 是给矿工的佣金，并以 ETH 支付，无论是交易、执行智能合约并启动 DApps，还是支付数据存储费用，都需要用到 Gas。

##### Gas price：

就是你愿意为一个Gwei为单位的gas出多少eth。矿工一般会优先打包gas price设置高的交易。1 ETH = 1000000000 Gwei

##### Gas limit：

1. 一种是用户交易的gas limit，即用户愿意为执行某个操作或确认某个交易支付的最大Gas量（普通转账为21000）。确切的Gas消耗量是在完成交易后才会知道，因此在你提交交易之前，需要为交易设定一个Gas用量的上限。如果说你提交的交易尚未完成，消耗的Gas就已经超过你设定的Gas Limit，那么这次交易就会被取消，而已经消耗的手续费同样被扣取 —— 因为要奖励已经付出劳动的矿工。 而如果交易已经完成，消耗的Gas未达到Gas Limit，那么只会按实际消耗的Gas 收取交易服务费，多余的会退回。 换句话说，一个交易可能被收取的最高服务费就是Gas Limit * Gas Price 了。如果出现网络拥堵，给出的 gasPrice 太小的时候，交易一直在 pending 状态，又想尽快完成交易时，可以重新发起一笔新的交易，提高 gasPrice，并将 nonce 值和被挂起的交易一样。那么旧交易就会被新交易所替代。
2. 还有一种是区块的gas limit，这个是单个区块允许的最多的gas总量，以此可以用来决定单个区块中能打包多少笔交易。例如，我们有5笔交易的gas limit分别是10、20、30、40和50.如果区块gas limit是100，那么前4笔交易就能被成功打包进入这个区块。矿工有权决定将哪些交易打包入区块。所以，另一个矿工可以选择打包最后两笔交易进入这个区块（50+40），然后再将第一笔交易打包（10）。如果你尝试将一个会使用超过当前区块gas limit的交易打包，这个交易会被网络拒绝，你的以太坊客户端会反馈错误"交易超过区块gas limit"。

### 共识

以太坊共有四个阶段，即Frontier（前沿）、Homestead（家园）、Metropolis（大都会）、Serenity（宁静）。以太坊前三个阶段采用的是POW共识机。第四个阶段将采用自己创建的POS机制，名为Casper投注共识，这种机制增加了惩罚机制，并基于POS的思想在记账节点中选取验证人。下面只讲解工作量证明：

以太坊目前采用的共识机制也是pow，比特币采用的共识机制也是PoW，矿工通过把网络尚未记录的现有交易打包到一个区块，然后不断遍历尝试来寻找一个随机数，使得新区块和随机数的哈希值满足一定的难度条件，例如前面10位是零。

找到满足条件的随机数，就相当于确定了区块链最新的一个区块，也相当于获得了区块链的本轮记账权。

矿工把满足挖矿难度条件的区块在网络中广播出去，全网其他节点在验证该区块满足挖矿难度条件，同时区块里的交易数据符合协议规范后，将各自把该区块链接到自己本地的区块链上，从而在全网形成对当前网络状态的共识。

工作量证明算法的意义在于，要找到这样一个随机数，没有比列举可能性更好的策略，而解决方案的验证又非常简单。由于输出有均匀分布（是散表功能应用的结果），我们可以保证，平均而言，需要找到这样一个随机数的时间取决于难度阈值。这使得只通过操纵难度来控制找到新区块的时间成为可能。

这种共识算法挖矿造成大量的资源浪费；挖矿的激励机制也造成矿池算力的高度集中，背离了当初去中心化设计的初衷。更大的问题是PoW机制的共识达成的周期较长，每秒最多只能做7笔交易，不适合商业应用。

### 出块时间

以太坊的出块时间是和难度调整算法相关的，算法主要是让挖矿时间保持在10-20s这个区间内，从而实现平均15s的目标，如果挖矿时间在0到9s内，会增大挖矿难度；如果挖矿时间大于20s，会减小难度。这个出块时间还会受到难度炸弹的影响，难度炸弹的主要作用是为了向权益证明过度，最右的相加项即为难度炸弹：

```
    block_diff = parent_diff + parent_diff / 2048 * max(1 - (block_timestamp - parent_timestamp) / 10, -99) + int(2^((block.number / 100000) - 2))
```

「以太坊难度炸弹」指的是以太坊所用的工作量证明算法难度调整机制中的一部分。难度炸弹则为挖矿难度加入了一个只随区块高度增加而增加、不随出块时间改变而改变的值。该值每 10 万个区块增加一次，永不下降。一开始难度炸弹增加的难度量很小，因此对出块时间没有明显影响；而且这部分难度量的上升也很缓慢，但它的增长接近指数型增长。所以到了一定时机，它会使网络难度突然增加，出块速度骤减。这就是我们所谓的「冰河期（Ice Age）」。

### 硬分叉和软分叉的区别

硬分叉：区块链发生永久性分歧，在新共识规则发布后，部分没有升级的节点无法验证已经升级的节点生产的区块，通常硬分叉就会发生。不向前兼容，旧版本不会接受新版本创建的合法区块，认为新版本的合法区块是不合法的。所以很明显硬分叉是不向前兼容。要实现硬分叉所有的用户（矿工，交易所，普通用户）都要切换的新的协议版本上。如果有至少51%的矿工的算力转向的新版本，那么网络自动完成软分叉：一开始旧版本创建的区块在新协议下被认为是不合法的，这时会出现一个短暂的分叉，但最终新版本的分叉会赶超旧版本的分叉成为最长链。因为在旧版本上的算力是小于新版本的，只要升级到最新的版本，分叉就会消除，这就是“软分叉”，软分叉是临时的。

软分叉：当新共识规则发布后，没有升级的节点会因为不知道新共识规则下，而产生不合法的区块，就会产生临时性分叉。向前兼容，旧的兼容新的，分叉的新规则是旧规则的子集，旧版本会接受新版本创建的区块，新版本和旧版本是兼容的。

# 比特币

**比特币**
SHA-256算法，链式加密结构，分布式数据库,通过P2P网络传输，社区共识为工作量证明（POW,Proof of work）的虚拟数字货币。比特币的发行总量为2100万，每个比特币又可以拆分成100万聪（satoshi）。在2009年1月4日，比特币的创世区块被发掘出来之后，每一个“胜利节点”将获得系统赏金50个比特币，当总量达到1050万时(2100万的50%)，赏金减半为25个。当总量达到1575万(新产出525万，即1050的50%)时，赏金再减半为12.5个，以此循环。这个计算过程就被形象地称为比特币挖矿，货币总量按照设计预定的速率逐步增加，增加速度逐步放缓，并最终在2140年达到2100万个的极限。参与挖矿的节点，被称为“矿工”。
**比特币中的非对称加密**
非对称加密就是两把钥匙，一把公钥，一把私钥。公钥公开，私钥保密。私钥在比特币中的运用为数字签名，你用私钥加密信息，别人用你的公钥解密证明确实是你发出的东西。在比特币转账的时候，利用被支付方的公钥加密一笔钱，支付方用私钥来解密这一笔钱，这一过程相当于取钱。
https://blog.csdn.net/u013372487/article/details/79440794

### 地址格式

1、BASE58格式
BASE58格式是人们常见的比特币地址格式，一般由1开头的。
2、HASH160格式
HASH160格式为RIPEMD160算法对130位公钥的SHA256签名进行计算得出的结果 。
3、WIF压缩格式
WIF压缩格式即钱包输入格式，是将BASE58格式进行压缩后的结果130位公钥格式 这是最原始的由ECDSA算法计算出来的比特币公钥。
4、60位公钥格式
60位公钥格式即130位公钥进行压缩后得出的结果。

### 隔离见证

**产生背景**
首先隔离见证是一种升级扩容的方案，由于交易量的增加和比特币区块大小的限制，区块很快就被填满，导致交易处理的速度越来越低。
其中比特币中的数据结构UTXO，UTXO直接决定了交易中资金的使用和支配权，在比特币交易中，转账者需要用私钥签名表明自己能够使用这笔资金，并加上接收者的地址，说明这笔比特币将转给谁。整个过程中签名占用了大量的字节，比特币网络中除了矿工需要验证（用公钥进行解密）这个签名，其他的普通节点只需要知道这个资金是不是可用的就行。因此就产生了一种把签名信息隔离出来的一种提议，在utxo中放一个指向签名信息的指针即可。
![img](http://0rac1esys.cn:3000/uploads/upload_24b21a249c2120a0a2c482e1209370ed.png)
隔离见证前
![img](http://0rac1esys.cn:3000/uploads/upload_1f30f62690fb0cb28e80ca4ceea5ed9e.png)
隔离见证后
**总结**
简单来说，隔离见证就是为应对交易量增加、区块很快被填满，导致交易处理效率下降而提出的一种另类的扩容方案。把utxo中的签名验证隔离出来，只在utxo中提供一个指针的指向签名验证。
https://blog.csdn.net/sxjinmingjie/article/details/77746180

### 共识

**共识机制**
在区块链中的共识机制简单的讲就是一个节点对交易进行打包，打包好的交易交给整个网络去验证。
**Pow共识机制**
简单的说就是不断的计算区块头哈希，直到与哈希值匹配的一个过程，哈希函数的结果无法提前得知，也没有能得到一个特定哈希值的模式。哈希函数的这个特性意味着：得到哈希值的唯一方法是不断的尝试，每次随机修改输入，直到出现适当的哈希值。
**共识逻辑**
通过计算得到哈希将获得奖励，但如果计算的哈希是不对的，将会得不到奖励，也消耗了资源。
**缺点**
所有的矿工都在计算哈希，但最终只有最先计算出的才能获得奖励，浪费了极大的算力。
https://blog.csdn.net/xq723310/article/details/80452929

### 出块时间

比特币的区块产生的速率保持在10分钟出块一个，在不同的全网算力条件下，新区块产生的速率需要保持这个速率，难度值需要根据全网算力进行调整。每2016个区块，都会根据统一的公式自动调整难度，这个公式是由最新的2016个区块花费时长和期望时长（按照10分钟一个块所计算得出的，总共20160分钟）比较得出的。（简单的说就是需要保持出块时间在10分钟一个块，保持的办法根据最新的2016个区块的总花费时长与期望时长计算出对于当前全网算力情况下的难易程度，调整计算的难度。在简单点说就是比十分钟快就加大难度，比十分钟慢就降低难度。）。
New Difficulty = Old Difficulty * (Actual Time of Last 2016 Blocks / 20160 minutes)

### 浏览器

常用的比特币区块链浏览器有：
https://btc.com/block
查看区块信息：
![](/uploads/upload_459e1022cd02b6a256c8171a3cbe7012.png)
https://www.blockchain.com/zh-cn/explorer
![](/uploads/upload_ee98d7824b96d5b02883c75cc759cb57.png)


### 硬分叉和软分叉的区别

**分叉的产生**
比特币的每次升级可能会伴随着区块链的共识规则改变，这会导致整个网络中升级了软件的节点与未升级软件的节点运行在不同的规则下，于是分叉就产生了。
**硬分叉**
如果区块链软件的共识规则被改变，并且这种规则改变无法向前兼容，旧节点无法认可新节点产生的区块，即为硬分叉。这时候旧节点会拒绝新规则的区块，于是新节点和旧节点会开始在不同的区块链上运行（挖矿、交易、验证等），由于新旧节点可能长期存在，这种分叉也可能会长期持续下去。
**硬分叉的过程**
1.开发者发布新的客户端，新的客户端改变了区块链的共识规则且不被旧客户端兼容，于是客户端软件出现了分叉（software fork）。
2.区块链网络中部分节点开始运行新的客户端，在新规则下产生的交易与区块将被旧节点拒绝，旧节点开始短暂的断开与这些发送被自己拒绝的交易与区块新节点的连接，于是整个区块链网络出现了分叉（network fork)。
3.运行新客户端的矿工开始基于新规则挖矿，并会接受新规则下的交易与区块，于是运行不同客户端版本的矿工算力出现了分叉（mining fork）。
4.运行新客户端的矿工开始挖出基于新规则的区块，而旧客户端的矿工仍然会挖掘基于旧规则的区块，于是整个区块链出现了分叉（chain fork）。
**软分叉**
如果区块链的共识规则改变后，这种改变是向前兼容的，旧节点可以兼容新节点产生的区块，即为软分叉。分叉通常刚开始并不会产生两条区块链，因为新规则下产生的块会被旧节点接受，旧节点只是无法识别新规则的真实意义。所以新旧节点仍然处于同一条区块链上，对整个系统的影响也就较小。
**硬分叉与软分叉的区别**
软分叉，旧节点可以接受新的节点，而硬分叉旧的节点无法接受新的节点会导致形成两条链。但是软分叉需要向前兼容，因此升级空间有限。
https://blog.csdn.net/chabuduoxiansheng1/article/details/79740018

### 解锁脚本和锁定脚本

『交易的发起者悬赏若干比特币，在网络上贴出了一到数学题，谁解出了这道数学题，悬赏就归谁了』。 顺着这个思路，Alice对Bob的转账可以理解为『Alice把一道只有Bob才能解开的数学题发到网络上，Bob解出题并拿走了悬赏』。那么，每个交易数据中都会出现的『脚本』就是题和解，『脚本语言』就是用来描述题和解的工具。——但所谓的解题就是验证身份的过程，所谓的悬赏就是别人转给你的以太币。我们这一步骤相当于验证身份取钱的过程。
![img](http://0rac1esys.cn:3000/uploads/upload_84d6557c279c1ff2fe3f98de537d7622.png)

1. 上图的三个交易都是单输入单输出交易
2. 每个『输入交易』『输出交易』中，都包含对应的『脚本』
3. 交易a，Alice转账给Bob；交易b，Bob转账给Carol；交易c，Carol转账给Dave
4. 当前交易的『输入』都引用前一个交易的『输出』，如交易b的『输入』引用交易a的『输出』
   P2PKH(Pay To Public Key Hash)，我们常用的转账方式：
   1.首先执行的是『输入脚本』。因为脚本是从左向右执行的，那么先入栈的是『签名』，随后是『公钥』
   ![img](http://0rac1esys.cn:3000/uploads/upload_0bdb7f7d0674b05dd11cecea9a6781f1.png)
   2.接着，执行的是『输出脚本』。从左向右执行，第一个指令是OP_DUP——复制栈顶元素
   ![img](http://0rac1esys.cn:3000/uploads/upload_44f08a458c82b0d56c4f52b212f4529e.png)
   3.OP_HASH160——计算栈顶元素Hash，得到pubkeyhash
   ![img](http://0rac1esys.cn:3000/uploads/upload_3a9dd48f484bc0a5396518fade7cab8a.png)
   4.将『输出脚本』中的『公钥哈希』入栈，为了和前面计算得到的哈希区别，称它为pubkeyhash’
   ![img](http://0rac1esys.cn:3000/uploads/upload_1b1730990c40a45703f16d8b4615e04f.png)
   5.OP_EQUALVERIFY——检查栈顶前两元素是否相等，如果相等继续执行，否则中断执行，返回失败
   ![img](http://0rac1esys.cn:3000/uploads/upload_ed3e490d9af5c8efcd0db692cdc9381f.png)
   6.OP_CHECKSIG——使用栈顶前两元素执行签名校验操作，如果相等，返回成功，否则返回失败
   ![img](http://0rac1esys.cn:3000/uploads/upload_ee1eb09d374bba3ce6db4d52a8fbf6de.png)
   小结：因为我们的地址是通过publickey加密而得来的，第三步和第四步以及第五步所做的事情是为了验证我这个钱是不是转给你这个人的，第六步所做的事情便是如果你是这个人，我凭什么相信你就是这个人，你必须拿出你的私钥签名和公钥，我进行验证
   ![img](http://0rac1esys.cn:3000/uploads/upload_3ce23ad5184d0b6e55dbfc4cddeb3c97.png)
   两种情况：
   （1）在提供我公钥和私钥的时候，但不是被转帐方，这样在验证地址的时候将会不通过
   （2）提供的公钥和签名不是成对的，就是加密后的地址是对应的，但在验证身份时是通不过的
    2.P2PK(Pay-to-Public-Key)
    锁定脚本： <Public Key B> OP_CHECKSIG
    解锁脚本：<Signature from Private Key B>
    合在一起： <Signature from Private Key B> <Public Key B> OP_CHECKSIG
    此脚本比P2PKH简单得多，只有一步验证，少了上方的地址验证，其实P2PKH被创建的主要目的之一是使比特币地址更简短，使之更方便使用，核心内容还是P2PK的。

    3.P2SH (Pay-to-Script-Hash) 支付到脚本哈希
    接收者先来构建一个赎回脚本（Redeem Script），里面的内容就是转出条件。注意，转出条件在 P2PKH 条件下是由发送者来写到上锁脚本中的。 接收者运算赎回脚本的哈希，这个哈希值就是一个 P2SH 类型的比    特币地址，并把这个哈希值发送给发送者。 发送者构建交易，但是这次的交易输出不再有上锁脚本，而是变成了赎回脚本的哈希。具体转出条件是什么，发送者是不知道的，也没有必要知道。 接收者收到币之后，如果想    花费这些币就必须去满足赎回脚本中的转出条件。例如，如果设置了适当的转出条件，就可以来实现多重签名。
    赎回脚本： OP_2 PUSHDATA(<PublicKey A> <PublicKey B> <PublicKey C>) OP_3 OP_CHECKMULTISIG
    锁定脚本：  OP_HASH160 PUSHDATA(<20-byte hash of Redeem Script>) OP_EQUAL
    解锁脚本： OP_0 PUSHDATA(<Signature B>) PUSHDATA(<Signature C>) PUSHDATA(<Redeem Script>)
    分两步执行，第一步验证赎回脚本的哈希：OP_0 PUSHDATA(<Signature B>) PUSHDATA(<Signature C>) PUSHDATA(<Redeem Script>) OP_HASH160 PUSHDATA(<20-byte hash of Redeem         Script>) OP_EQUAL
    第二步执行赎回脚本：OP_2 PUSHDATA(<PublicKey A> <PublicKey B> <PublicKey C>) OP_3 OP_CHECKMULTISIG
    这里OP_0其实是因为OP_CHECKMULTISIG执行的时候的一个bug，会多弹出一个元素，所以为了避免出错，将一个没用的值放到栈底。

    4.MS(Multiple Signatures)多重签名
    2-3多重签名
    锁定脚本： 2 <Public Key A> <Public Key B> <Public Key C> 3 OP_CHECKMULTISIG
    解锁脚本： OP_0 <Signature B> <Signature C>
    合在一起： OP_0 <Signature B> <Signature C> 2 <Public Key A> <Public Key B> <Public Key C> 3 OP_CHECKMULTISIG

   https://www.chainnode.com/tutorial/1961